package ecdh

import (
	"crypto"
	"crypto/elliptic"
	"io"
	"math/big"
	"encoding/pem"
	"crypto/x509"
	"bytes"
	"errors"
	"encoding/asn1"
	"crypto/x509/pkix"
	"crypto/ecdsa"
)


type EllipticECDH struct {
	ECDH
	curve elliptic.Curve
}

type EllipticPublicKey struct {
	elliptic.Curve
	X, Y *big.Int
}

type EllipticPrivateKey struct {
	D []byte
}

type publicKeyInfo struct {
	Raw       asn1.RawContent
	Algorithm pkix.AlgorithmIdentifier
	PublicKey asn1.BitString
}

// NewEllipticECDH creates a new instance of ECDH with the given elliptic.Curve curve
// to use as the elliptical curve for elliptical curve diffie-hellman.
func NewEllipticECDH(curve elliptic.Curve) *EllipticECDH {
	return &EllipticECDH{
		curve: curve,
	}
}

func (e *EllipticECDH) GenerateKey(rand io.Reader) (crypto.PrivateKey, crypto.PublicKey, error) {
	var d []byte
	var x, y *big.Int
	var priv *EllipticPrivateKey
	var pub *EllipticPublicKey
	var err error

	d, x, y, err = elliptic.GenerateKey(e.curve, rand)
	if err != nil {
		return nil, nil, err
	}

	priv = &EllipticPrivateKey{
		D: d,
	}
	pub = &EllipticPublicKey{
		Curve: e.curve,
		X:     x,
		Y:     y,
	}

	return priv, pub, nil
}

func (e *EllipticECDH) Marshal(p crypto.PublicKey) ([]byte, error) {
	pub := p.(*EllipticPublicKey)
	return elliptic.Marshal(e.curve, pub.X, pub.Y), nil
}

func (e *EllipticECDH) Unmarshal(data []byte) (crypto.PublicKey, error) {
	var key *EllipticPublicKey
	var x, y *big.Int

	x, y = elliptic.Unmarshal(e.curve, data)
	if x == nil || y == nil {
		return key, errors.New("failed to unmarshal elliptic curve")
	}
	key = &EllipticPublicKey{
		Curve: e.curve,
		X:     x,
		Y:     y,
	}
	return key, nil
}

func (e *EllipticECDH) X509Marshal(p crypto.PublicKey) ([]byte, error) {
	pub := p.(*EllipticPublicKey)
	ecdsaPubKey := &ecdsa.PublicKey{}
	ecdsaPubKey.Curve = pub.Curve
	ecdsaPubKey.X = pub.X
	ecdsaPubKey.Y = pub.Y
	// public key to der-format
	pubbuf, err := x509.MarshalPKIXPublicKey(ecdsaPubKey)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	// der-format to pem
	err = pem.Encode(&buf, &pem.Block{Type: "PUBLIC KEY", Bytes: pubbuf})
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (e *EllipticECDH) X509Unmarshal(data []byte) (crypto.PublicKey, error) {
	// pem decode public key to der-format
	block, _ := pem.Decode(data)
	if block == nil {
		return nil, errors.New("invalid pem format")
	}
	// Go assumes that an ECDSA curve as specified in a certificate is always going to be a named curve. (https://github.com/golang/go/issues/21502#issuecomment-323400475)
	// if the public is generated by "-param_enc explicit",
	// golang doesn't support to parse  ECParameters. more info: https://www.ietf.org/rfc/rfc5480.txt at 2.1.1.  Unrestricted Algorithm Identifier and Parameters
	// if the public is generated by "-param_enc named_curve" x509.ParsePKIXPublicKey can parse this der-format,
	// the following code is for convenience, ignore parsing AlgorithmIdentifier

	// der-format to public key
	var pki publicKeyInfo
	_, err := asn1.Unmarshal(block.Bytes, &pki)
	if err != nil {
		return nil, err
	}
	curve := e.curve
	x, y := elliptic.Unmarshal(curve, pki.PublicKey.RightAlign())
	if x == nil {
		return nil, errors.New("failed to unmarshal elliptic curve")
	}
	pubKey := &EllipticPublicKey{Curve: curve, X: x, Y: y}
	return pubKey, nil
}


// GenerateSharedSecret takes in a public key and a private key
// and generates a shared secret.
//
// RFC5903 Section 9 states we should only return x.
func (e *EllipticECDH) GenerateSharedSecret(privKey crypto.PrivateKey, pubKey crypto.PublicKey) ([]byte, error) {
	priv := privKey.(*EllipticPrivateKey)
	pub := pubKey.(*EllipticPublicKey)

	x, _ := e.curve.ScalarMult(pub.X, pub.Y, priv.D)
	return x.Bytes(), nil
}
