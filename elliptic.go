package ecdh

import (
	"crypto/elliptic"
	"io"
	"math/big"
	"encoding/pem"
	"crypto/x509"
	"bytes"
	"errors"
	"encoding/asn1"
	"crypto/x509/pkix"
	"crypto/ecdsa"
)

type EllipticECDH struct {
	ECDH
	curve elliptic.Curve
}

type EllipticPublicKey struct {
	elliptic.Curve
	X, Y *big.Int
}

type EllipticPrivateKey struct {
	EllipticPublicKey
	D *big.Int
}

type publicKeyInfo struct {
	Raw       asn1.RawContent
	Algorithm pkix.AlgorithmIdentifier
	PublicKey asn1.BitString
}

// NewEllipticECDH creates a new instance of ECDH with the given elliptic.Curve curve
// to use as the elliptical curve for elliptical curve diffie-hellman.
func NewEllipticECDH(curve elliptic.Curve) *EllipticECDH {
	return &EllipticECDH{
		curve: curve,
	}
}

func (e *EllipticECDH) GenerateKey(rand io.Reader) (*EllipticPrivateKey, *EllipticPublicKey, error) {
	var d []byte
	var x, y *big.Int
	var priv *EllipticPrivateKey
	var pub *EllipticPublicKey
	var err error

	d, x, y, err = elliptic.GenerateKey(e.curve, rand)
	if err != nil {
		return nil, nil, err
	}

	priv = &EllipticPrivateKey{
		D: new(big.Int).SetBytes(d),
	}
	pub = &EllipticPublicKey{
		Curve: e.curve,
		X:     x,
		Y:     y,
	}

	return priv, pub, nil
}

func (e *EllipticECDH) Marshal(pub *EllipticPublicKey) ([]byte, error) {
	return elliptic.Marshal(e.curve, pub.X, pub.Y), nil
}

func (e *EllipticECDH) Unmarshal(data []byte) (*EllipticPublicKey, error) {
	var key *EllipticPublicKey
	var x, y *big.Int

	x, y = elliptic.Unmarshal(e.curve, data)
	if x == nil || y == nil {
		return key, errors.New("failed to unmarshal elliptic curve")
	}
	key = &EllipticPublicKey{
		Curve: e.curve,
		X:     x,
		Y:     y,
	}
	return key, nil
}

func (e *EllipticECDH) X509MarshalPublicKey(pub *EllipticPublicKey) ([]byte, error) {
	ecdsaPubKey := &ecdsa.PublicKey{}
	ecdsaPubKey.Curve = pub.Curve
	ecdsaPubKey.X = pub.X
	ecdsaPubKey.Y = pub.Y
	// public key to der-format
	pubbuf, err := x509.MarshalPKIXPublicKey(ecdsaPubKey)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	// der-format to pem
	err = pem.Encode(&buf, &pem.Block{Type: "PUBLIC KEY", Bytes: pubbuf})
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (e *EllipticECDH) X509UnmarshalPublicKey(data []byte) (*EllipticPublicKey, error) {
	// pem decode public key to der-format
	block, _ := pem.Decode(data)
	if block == nil {
		return nil, errors.New("invalid pem format")
	}
	// Go assumes that an ECDSA curve as specified in a certificate is always going to be a named curve. (https://github.com/golang/go/issues/21502#issuecomment-323400475)
	// if the public is generated by "-param_enc explicit",
	// golang doesn't support to parse  ECParameters. more info: https://www.ietf.org/rfc/rfc5480.txt at 2.1.1.  Unrestricted Algorithm Identifier and Parameters
	// if the public is generated by "-param_enc named_curve" x509.ParsePKIXPublicKey can parse this der-format,
	// the following code is for convenience, ignore parsing AlgorithmIdentifier

	// der-format to public key
	var pki publicKeyInfo
	_, err := asn1.Unmarshal(block.Bytes, &pki)
	if err != nil {
		return nil, err
	}
	curve := e.curve
	x, y := elliptic.Unmarshal(curve, pki.PublicKey.RightAlign())
	if x == nil {
		return nil, errors.New("failed to unmarshal elliptic curve")
	}
	pubKey := &EllipticPublicKey{Curve: curve, X: x, Y: y}
	return pubKey, nil
}

func (e *EllipticECDH) X509UnmarshalPrivateKey(pemBytes []byte) (*EllipticPrivateKey, error) {
	// pem decode public key to der-format
	block, _ := pem.Decode(pemBytes)
	if block == nil {
		// return nil, errors.New("invalid pem format")
	}

	// parse der
	tp, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		return nil, err
	}

	ecPriKey := &EllipticPrivateKey{D: tp.D}
	ecPriKey.Curve = tp.Curve
	ecPriKey.X = tp.X
	ecPriKey.Y = tp.Y

	return ecPriKey, nil
}

func (e *EllipticECDH) X509MarshalPrivateKey(priKey *EllipticPrivateKey) ([]byte, error) {
	ecdsaPriKey := &ecdsa.PrivateKey{
		D: priKey.D,
	}
	data, err := x509.MarshalECPrivateKey(ecdsaPriKey)
	if err != nil {
		return nil, err
	}
	return data, nil
}

// GenerateSharedSecret takes in a public key and a private key
// and generates a shared secret.
//
// RFC5903 Section 9 states we should only return x.
func (e *EllipticECDH) GenerateSharedSecret(priv *EllipticPrivateKey, pub *EllipticPublicKey) ([]byte, error) {
	x, _ := e.curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
	xBytes := x.Bytes()
	xByteSize := len(xBytes)
	// https://github.com/golang/go/issues/26020#issuecomment-404696978
	size := len(e.curve.Params().N.Bytes())
	if xByteSize < size {
		newXBytes := make([]byte, size)
		copy(newXBytes[size - xByteSize:], xBytes)
		xBytes = newXBytes
	}
	return xBytes, nil
}
